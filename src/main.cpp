#include <Arduino.h>
#include <driver/adc.h>
#include <esp32/ulp.h>

// Third-party libs
#include <Chrono.h>
#include <ulptool.h>

// Special header generated by ulptool
#include "ulp_main.h"

// Local headers
#include "EEE.h"
#include "mqtt_reporter.h"
#include "pm.h"
#include "ulp_common.h"

#define ULP_WAKEUP_PERIOD_US (1000 * 1000)
#define POWER_MANAGEMENT_TASK_POLL_MS 500

extern const uint8_t ulp_main_bin_start[] asm("_binary_ulp_main_bin_start");
extern const uint8_t ulp_main_bin_end[] asm("_binary_ulp_main_bin_end");

Chrono powerManagerTask;

static void init_run_ulp(uint32_t usec) {
    ulp_set_wakeup_period(0, usec);
    esp_deep_sleep_disable_rom_logging(); // suppress boot messages

    esp_err_t err = ulptool_load_binary(
        0, ulp_main_bin_start,
        (ulp_main_bin_end - ulp_main_bin_start) / sizeof(uint32_t));
    err = ulp_run((&ulp_entry - RTC_SLOW_MEM) / sizeof(uint32_t));

    adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_11);
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_ulp_enable();

    if(err) {
        Serial.println("Error Starting ULP Coprocessor");
    }

    esp_sleep_enable_ulp_wakeup();
}

void report(bool isRunning) {
#ifdef USE_MQTT_REPORTER
    uint16_t batVraw = (ulp_batV & 0xFFFF);
    uint16_t batV = (float)batVraw * 1.76f;

    mqtt_data_map_t dataMap{{"millis", String(millis())},
                            {"batV", String(batV)},
                            {"batVraw", String(batVraw)},
                            {"isRunning", String((uint8_t)isRunning)}};

    MqttReporter::report(dataMap);
#endif
}

void setup() {
    PM::disableBusPower();
    Serial.begin(921600);
    Serial.println("Started");

    esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();
    if(cause != ESP_SLEEP_WAKEUP_ULP) {
        Serial.println("Not ULP wakeup, initializing ULP");
        init_run_ulp(ULP_WAKEUP_PERIOD_US);
        // TODO: Restore variables from non-volatile memory
    } else {
        Serial.println("ULP wakeup");
        esp_sleep_enable_ulp_wakeup();

        // If ULP requested to run the periodic task, run it and back to sleep
        // immediately.
        if(PM::isPeriodicTaskRequested(ulp_status)) {
            Serial.println("PeriodicTask is requested at wake");
            PM::clearPeriodicTaskRequest(ulp_status);
            report(false);
            esp_deep_sleep_start();
        }

        if(PM::isWakeVoltageSatisfied(ulp_status)) {
            PM::clearEmergencyTaskRequest(ulp_status);
        }
        if(PM::isEmergencyTaskRequested(ulp_status)) {
            // TODO: Save variables to non-volatile memory
            esp_deep_sleep_start();
        }

        // Restore variables from RTC SLOW RAM
        EEE.fileInd = ulp_fileInd & 0xFFFF;
        EEE.frameInd =
            (ulp_frameIndH & 0xFFFF) << 16 | (ulp_frameIndL & 0xFFFF);
        Serial.printf("fileInd: %u, frameInd: %u", EEE.fileInd, EEE.frameInd);
    }

    PM::enableBusPower();

    if(!EEE.begin()) {
        ESP.restart();
    }

    MqttReporter::begin();
}

void loop() {
    if(PM::isPeriodicTaskRequested(ulp_status)) {
        PM::clearPeriodicTaskRequest(ulp_status);
        Serial.println("PeriodicTask is requested.");
        report(true);
    }

    if(powerManagerTask.hasPassed(POWER_MANAGEMENT_TASK_POLL_MS)) {
        powerManagerTask.restart();
        uint32_t batV = (ulp_batV & 0xFFFF);
        if(batV <= PM_VBAT_TH_SLEEP) {
            Serial.printf("Entering deep sleep. batV: %u\n", batV);
            ulp_frameIndH = EEE.frameInd >> 16;
            ulp_frameIndL = EEE.frameInd & 0xFFFF;

            PM::disableBusPower();
            esp_deep_sleep_start();
        }
    }

    // Render a video frame
    EEE.handle();
}
